Часто во время обучения программированию стоит вопрос: что ещё можно запрограммировать?
Сначала стоит пробовать небольшие алгоритмические задачи. Они могут быть скучными, но их нужно делать, чтобы развить своё мышление.

****????
ФИксировать ошибки

1. Алгоритмы работы с массивами

1) Скопировать одну часть массива в другой массив
copyArray(sourceArray, ref destArray, startIndex, len)

Если destArray == null, создать массив


2) Реверсировать массив (порядок элементов массива должен быть противоположен исходному). То есть если он был 0,1,2,3, то будет 3,2,1,0

3) Переставьте элементы массива 0,1,2,3,4... в порядке 0,8,16,24,32, ... , 1,9,17,..., 2,10,18,...
То есть исходный массив должен быть, с точки зрения логики, разбит на части по 8-мь элементов. 

Сначала мы копируем в новый массив все элементы с индексом "0" из каждой части, потом с индексом "1" из каждой части и т.п.
Длина исходного массива всегда кратна 8-ми.

4) Проверьте, что в массиве нет повторяющихся элементов (сортировка, см. пункт 2, потом проверка на то, что каждый элемент массива не совпадает с предыдущим элементом)

5) Реализуйте прокси-объект, который обращается к исходному массиву без его изменения и создания другого массива. При этом, он реализует всё то же, что и в упражнения 1, 2, 3.

То есть у вас есть некий класс, у которого есть методы получения значения массива по его индексу.
Если у вас в языке есть индексаторы (C#, object pascal), то сделайте это через индексаторы.


2. Алгоритмы сортировки

Можно попробовать начать с реализации алгоритмов сортировки. Не забудьте всё тщательно тестировать автоматизированными тестами (которые вам тоже надо написать - тесты можно использовать одни и те же для разных реализаций).

Особенно можно обратить внимание на следующие алгоритмы:
1) Сортировка выбором максимального или минимального элемента (то есть каждый проход вы выбираете самый большой или маленький элемент и ставите его в начало; потом снова осуществляете проход и т.п.). Этот алгоритм интересен простотой реализации, если вам где-то понадобилось быстро реализовать такой поиск.
2) Усложнённая сортировка выбором: на каждой итерации вы ищете максимальный и минимальный элементы
Замерьте время выполнения алгоритма 1) и 2) на разных массивах. Прирост производительности должен быть примерно в 2 раза.
3) Поразрядная сортировка. Хороша, чтобы понять, как работает быстрая сортировка
4) Быстрая сортировка (quick sort). Она хороша на малых массивах
5) Сортировка слиянием. Самый универсальный способ, пригодный как для массивов, так и для односвязных и двусвязных списков.
6) Сортировка вставками (самый медленный из всех). Этот способ интересен тем, что вам нужно реализовать бинарный поиск в массиве со вставками.
7) Сортировка пузырьком. Этот способ интересен тем, что иногда применяется в алгоритмах оптимизации для сортировки элементов, которые могут давать различные результаты сравнения (то есть a >= b даёт разные результаты от одного вычисления этого сравнения к другому вычислению).
8) Пирамидальная сортировка и сортировка с помощью деревьев, если вы способны реализовать эти алгоритмы. Они сложные - годятся для тренировки (лично я их никогда не реализовывал)


Упражнение на тесты:
Для тестов, в том числе, сгенерируйте массив из 8-ми элементов: [-1, 0, 1, 2, 3, 4, 5, 6].
Сгенерируйте все возможные перестановки этого массива (их количество 8!=40320 [восклицательный знак - это факториал]). Для всех перестановок результат сортировки должен быть верным.

2.1. Алгоритмы сортировки: паралеллизм

1) Попробуйте распараллелить на два потока сортировку выбором. Сравните результат с усложнённой сортировкой выбором (скорее всего, производительность будет несколько хуже у двухпоточного варианта за счёт большей нагрузки на шину данных - проходов по массиву такой алгоритм совершает больше, чем надо)
2) Попробуйте распараллелить алгоритм сортировки слиянием. Если не получается, начните с двух потоков.


3. Парсер калькулятора

1) Сделайте калькулятор, который способен понимать скобки, операции +, -, *, /, ^ (возведение в степень)
Не забудьте о приоритете операций.
Не делайте это на основе таких функций, как string.split и т.п.
Разбирайте строки посимвольно в абстрактное синтаксическое дерево и потом уже обрабатывайте его
Если тяжело, попробуйте, сначала, ограничиться операциями + и -. А потом уже добавить всё остальное (обратите внимание, мы упрощаем задачу - это частый приём, если сложная задача сразу не поддаётся)

2) Также калькулятор должен вычислять многострочные выражения, где можно определять переменные.

3) Попробуйте добавить в калькулятор возможность определения и вызова функций


4. 

Решето эратосфена и битовые массивы


Работа с UTF-8

Гмурман
