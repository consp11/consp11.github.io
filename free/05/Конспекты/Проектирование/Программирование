Основные приёмы программирования:
    Напиши сценарии использования
    Не забудь, что поиск (буквально поиск по ключевым словам, названиям компонентов, функций и событий) внутри программы какого-то компонента должен быть достаточно простым. Когда пишешь абстракции или другим образом маскируешь вызовы, подумай, нужно ли это и сделай дополнительные комментарии к этому. Если надо, напиши программы, чтобы они могли указать, какой выбор и из каких данных сделает программа, поток управления которой настраивается данными, полученными во время выполнения. Если надо, напиши специализированный язык программирования.
    При проектировании ответь на следующие вопросы (если они внушают опасения)
        Как ты будешь тестировать этот код (в автоматическом режиме)?
        Какие ошибки должны быть выявлены тестами?
        Какие проблемы с безопасностью могут быть и как их решать?
        Нужны ли дополнительные приёмы безопасного программирования и защитного программирования?
        Должна ли программа быть удобно разграничиваемой (или даже по умолчанию разграниченной)?
            В частности:
                Файловая система и chroot
                Список прогрмамм и библиотек, которые нужны для запуска
                apparamor
                    список программ и их привелегий, к которым обращается программа
                    список ввода-выводы
                сеть
                    возможность использования proxy
                    какие адреса или доменные имена использует программа?
        Должна ли быть программа расширяемой без перекомпиляции или без изменения каких-то участков кода?
        Будет использован метод копирования и изменения для новых версий алгоритмов, или будут использованы абстрактные обёртки и настройки, в том числе наследование в ООП?
        Обновление программы поверх уже установленной программы
        Что может измениться со временем? (простые поля превращаются в массивы или сложные объекты и т.п.)
        Хватает ли производительности и не будет ли её существенной деградации со временем (когда данных будет много даже log(n) может стать проблемой)
        Нужна ли многопоточность?
        Нужно ли резервное копирование "на лету" и вообще резервное копирование? Другая отказоустойчивость и требования к готовности?
        Как именно будет реализована итеративность и инкрементальность разработки?
        Нужно ли разделять приложение на разные сервисы, которые могут работать независимо друг от друга?
        Как сделать приложение быстро компилирующимся при изменениях, чтобы можно было легко и быстро вносить изменения, делать отладочный вывод, тестирование и т.п.?




Принцип простоты и минимизации
    Меньше функциональности - проще программа. Меньше задач или они унифицированы - проще программа (не всегда).
    Что здесь ещё можно убрать?
    Проще код
        Код должно быть просто читать и просто использовать
            Если реализуешь стандарт, напиши по пунктам что именно ты делаешь в каждом случае
                Все нюансы и сценарии использвания должны быть, по возможности, разъяснены,
                    чтобы не попасть на проблемы с тем, что код при изменениях будет не понятен
                Комментируй не то, что делает программа, а то, что она должна делать и почему
            Хуже чем документация без примеров только документация с одним примером
                Делай документацию так, чтобы:
                    продемонстрировать конкретные сценарии использования (и быстро освоиться с ПО)
                    дать описание полных возможностей и понимание, как что работает
                    понять, как обеспечивается безопасность
                    в конечном итоге, примеров должно быть столько, чтобы это было похоже уже на тесты,
                        чтобы точно не осталось никаких если и но
                    запрограммируй тесты так, чтобы если будет изменён код, не забыть изменить и документацию
                        напиши в тестах, где нужно изменить документацию, если тест изменяется
                        в идеале, напиши отдельный тест именно на документацию
        В коде должно быть просто найти нечто. Если обрабатывается событие, его должно быть легко найти поиском по имени события. Получается объект из фабрики - это должно быть легко понять, где это, зная имя фабрики. И т.п.
        Если нужно, нужно копипастить (помечая код)
        Избегать инверсии управления там, где можно (весь код должен читаться без абстракций).
        Избегать настроек, которые влияют на граф потока управления. Если такие настройки есть - сделай документацию по ним: что, где, какие есть варианты, куда смотреть в коде и где эти настройки.
        Форматы внешних сервисов, которые тяжело вызывать, стоит документировать (с примерами). Таблицы в БД, сложные данные в коде - тоже.
        Где это упрощает, делать абстрактные алгоритмы
        Вводить новые термины, если нужно
        Используй более простые технологии, если допустима меньшая производительность,
            но большая простота программирования (размен производительности ПО на простоту программирования)
        Фильтры для ловли ошибок в слабых местах:
            Расположи в коде проверки, что код корректный, чтобы потом было легко локализовать ошибку
            По возможности, работай с автоматическими тестами, чтобы знать, где ошибки
    Экономическая эффективность
        Не делай сегодня то, что можно сделать завтра
        Сделай так, чтобы изменения завтра не были бы проблемой
            Учти, что поле объекта сейчас может превратиться в массив или сложный объект
            Учти, что версии могут измениться
                (хотя бы поставь номер версии в данных, чтобы версию можно было бы без труда отработать)
        Делай то, что приносит прибыль
    
    Абстрагирование:
        абстрактные слои и прочие абстрагирующие вещи
        введение терминологии (новые классы, функции) как элемент абстракции [выделение терминологии из описания алгоритма, требований к безопасности или ТЗ, чтобы понять, всё ли мы хотим правильно сделать, не забыли ли каких терминов]

    Изоляция и разделение (инкапсуляция)
        Код должен быть разделён на фрагменты, если возможно, которые инкапсулируют
        Повторное использование кода - это следствие того, что проект разделён на компоненты
        Компоненты нужны только там, где ты знаешь, как их разделить, где они хорошо делятся

    Везде и всё должно быть к месту, нужно  понимать, что и для чего ты делаешь


    Резервное копирование и безопасность
        Позаботься о масштабировании (параллелизм) (если будет нужно)
        Позаботься о резервном копировании заранее (с учётом параллелизма),
            не доверяй стандартным функциям резервного копирования,
                проверь, что они верно работают
                    и при изменении в программе будет обеспечена прямая совместимость
            Позаботься о резервном копировании без остановки процессов и нарушения целостности
                    (если будет нужно)
                Позаботься о ручном восстановлении, и чтоб его было как можно меньше (если будет нужно)
        Позаботься о безопасности или возможности её вставки в дальнейшем (разработай примерную схему защиты)
            Используй везде аутентифицированную криптографию, если туда может влезть противник
            Многоэшелонированная оборона
            Посмотри, что твоя программа хорошо подвергается разграничению доступа
                Если нужно, разбей программу на части (на разные процессы или даже компьютеры)
            Используй как можно меньше стороннего кода
            Используй сторонний код, если чувствуешь, что он более качественный или ты не знаешь, как его сделать
            Используй безопасные технологии
            Помни, что в твоей программе есть ошибка безопасности. Программируй так, чтобы её парировать

    Итеративность и инкрементальность
        Сделай сначала те функции, которые приносят наибольшую прибыль, так как, возможно, остальные функции просто не потребуются. Сделай так, чтобы каждая итерация могла быть запущена и приносила прибыль (а не только последние)
        Сделай сначала сложные функции
        Сделай сначала костяк, на который можно навешивать мясо (не всегда верно, иногда, можно делать тесты)
        Программа должна всегда запускаться, лучше всего, если это будут не только тесты

Принцип сложности и синергии
    Смотри, где будет нужно оптимизировать заранее, чтобы потом было проще. Оптимизируй ещё на уровне архитектуры. Смотри, всё ли выполнимо в вычислительном плане.
    Иногда нужно сделать сложно, но нужно сделать
    Иногда нужно сделать настраиваемо
        В данном случае, возможно, стоит сделать специализированный язык программирования,
            чтобы избежать слишком абстрактного кода и инверсии управления
    Иногда нужно сделать так, чтобы части системы взаимодействовали между собой,
        усиливая их по мелочам, там, где получается, но везде
        В том числе, чтобы слабости компьютера компенсировал человек и наоборот

Проверяй
    На всё, что является промышленным кодом, нужны автоматические тесты.
        Классы эквивалентности
        Комбинаторное тестирование: пройти по всем возможным потокам управления и по всем возможным вариантам логических правил, которые дают условные переходы
        Тестирование функциональных ветвей: пройти по всему, что
        Повторный запуск того же самого кода
        Тестирование на соответствие более простому коду или даже выражениям, вычисленным вручную
        Оформляй документацию по коду, при просмотре кода оформляй документацию по тому, что нет типовых ошибок в каждой строке кода. Оформляй состояния и разрешённые между ними переходы. Используй (и создавай) списки типовых ошибок.
        Задумывайся уже после программирования (даже через годы), как работает программа и учла ли она какие-либо варианты
    Приёмы проверки
        Проверяй всё в отладчике: проходи по строкам кода:
            Какие переменные должны измениться?
            Какие у них должны быть значения?
            Какие не должны?
        

Комментарии
    В комментариях необходимо писать не то, что делает программа, но твои намерения (что она должна сделать)
    Если реализуется стандарт - необходимо каждую строку кода снабжать подробными комментариями со ссылкой на стандарт
    Если есть взаимодействие с другими программмами, часто нужно комментировать все строки кода, чтобы было понятно, что именно происходит (если это не очень просто), т.к. часто при чтении кода совершенно непонятно, что даёт другая программа на выход нам

    Самодокументируемость: классы, перменные и поля поименованны так, что становится понятно, что они делают или хранят. Классы вводят абстрагирующие термины, возможно, предметно-ориентированные.

    Если программист-пользователь может полагаться на какие-то предположения, хорошо записать, верны ли эти предположения. Например, при вставке в какого-либо логического объекта и отношения между объектами в базу данных, где хранятся отношения между объектами, - замыкается ли транзитивно множество отношений этих объектов автоматически? Или его нужно замкнуть вручную?
    В каком порядке допускается использовать методы объекта? В каких состояниях может пребывать объект? (один или несколько конечных автоматов).

