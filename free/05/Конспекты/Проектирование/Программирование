Принцип простоты и минимизации
    Меньше функций
    Что здесь ещё можно убрать?
    Проще код
        Код должно быть просто читать и просто использовать
            Если реализуешь стандарт, напиши по пунктам что именно ты делаешь в каждом случае
                Все нюансы и сценарии использвания должны быть, по возможности, разъяснены,
                    чтобы не попасть на проблемы с тем, что код при изменениях будет не понятен
                Комментируй не то, что делает программа, а то, что она должна делать и почему
            Хуже чем документация без примеров только документация с одним примером
                Делай документацию так, чтобы:
                    продемонстрировать конкретные сценарии использования (и быстро освоиться с ПО)
                    дать описание полных возможностей и понимание, как что работает
                    понять, как обеспечивается безопасность
                    в конечном итоге, примеров должно быть столько, чтобы это было похоже уже на тесты,
                        чтобы точно не осталось никаких если и но
                    запрограммируй тесты так, чтобы если будет изменён код, не забыть изменить и документацию
                        напиши в тестах, где нужно изменить документацию, если тест изменяется
                        в идеале, напиши отдельный тест именно на документацию
        Если нужно, нужно копипастить (помечая код)
        Избегать инверсии управления там, где можно (весь код должен читаться без абстракций)
        Где это упрощает, делать абстрактные алгоритмы
        Вводить новые термины, если нужно
        Используй более простые технологии, если допустима меньшая производительность,
            но большая простота программирования (размен производительности ПО на простоту программирования)
        Фильтры для ловли ошибок в слабых местах:
            Расположи в коде проверки, что код корректный, чтобы потом было легко локализовать ошибку
            По возможности, работай с автоматическими тестами, чтобы знать, где ошибки
    Экономическая эффективность
        Не делай сегодня то, что можно сделать завтра
        Сделай так, чтобы изменения завтра не были бы проблемой
            Учти, что поле объекта сейчас может превратиться в массив или сложный объект
            Учти, что версии могут измениться
                (хотя бы поставь номер версии в данных, чтобы версию можно было бы без труда отработать)
        Делай то, что приносит прибыль
    
    Абстрагирование:
        абстрактные слои, медиаторы (врапперы)
        введение терминологии (новые классы, функции) как элемент абстракции [выделение терминологии из описания алгоритма, требований к безопасности или ТЗ, чтобы понять, всё ли мы хотим правильно сделать, не забыли ли каких терминов]

    Резервное копирование и безопасность
        Позаботься о масштабировании (параллелизм) (если будет нужно)
        Позаботься о резервном копировании заранее (с учётом параллелизма),
            не доверяй стандартным функциям резервного копирования,
                проверь, что они верно работают
                    и при изменении в программе будет обеспечена прямая совместимость
            Позаботься о резервном копировании без остановки процессов и нарушения целостности
                    (если будет нужно)
                Позаботься о ручном восстановлении, и чтоб его было как можно меньше (если будет нужно)
        Позаботься о безопасности или возможности её вставки в дальнейшем (разработай примерную схему защиты)
            Используй везде аутентифицированную криптографию, если туда может влезть противник
            Многоэшелонированная оборона
            Посмотри, что твоя программа хорошо подвергается разграничению доступа
                Если нужно, разбей программу на части (на разные процессы или даже компьютеры)
            Используй как можно меньше стороннего кода
            Используй сторонний код, если чувствуешь, что он более качественный или ты не знаешь, как его сделать
            Используй безопасные технологии
            Помни, что в твоей программе есть ошибка безопасности. Программируй так, чтобы её парировать

    Итеративность и инкрементальность
        Сделай сначала те функции, которые приносят наибольшую прибыль, так как, возможно, остальные функции просто не потребуются. Сделай так, чтобы каждая итерация могла быть запущена и приносила прибыль (а не только последние)
        Сделай сначала сложные функции
        Сделай сначала костяк, на который можно навешивать мясо (не всегда верно, иногда, можно делать тесты)
        Программа должна всегда запускаться, лучше всего, если это будут не только тесты

Принцип сложности и синергии
    Смотри, где будет нужно оптимизировать заранее, чтобы потом было проще. Оптимизируй ещё на уровне архитектуры. Смотри, всё ли выполнимо в вычислительном плане.
    Иногда нужно сделать сложно, но нужно сделать
    Иногда нужно сделать настраиваемо
        В данном случае, возможно, стоит сделать специализированный язык программирования,
            чтобы избежать слишком абстрактного кода и инверсии управления
    Иногда нужно сделать так, чтобы части системы взаимодействовали между собой,
        усиливая их по мелочам, там, где получается, но везде
        В том числе, чтобы слабости компьютера компенсировал человек и наоборот


Комментарии
    В комментариях необходимо писать не то, что делает программа, но твои намерения (что она должна сделать)
    Если реализуется стандарт - необходимо каждую строку кода снабжать подробными комментариями со ссылкой на стандарт
    Если есть взаимодействие с другими программмами, часто нужно комментировать все строки кода, чтобы было понятно, что именно происходит (если это не очень просто), т.к. часто при чтении кода совершенно непонятно, что даёт другая программа на выход нам
